# 아이템 26: 함수 내부의 추상화 레벨을 통일하나

컴퓨터는 복잡한 장치를 여러가지 계층으로 분할하여 사용한다.
- 물리장치
- 하드웨어
- 프로세서 제어명령
- 어셈블리
- 프로그래밍 언어
- 가상머신
- 어플리케이션

계층이 잘 분리되면 어떤 계층에서 작업할 때 해당 계층만 생각하면 된다. 아래 계층 전체를 이해할 필요가 없다.

## 추상화 레벨
높은 례벨로 갈 수록 물리 장치로부터 점점 멀어지고 걱정해야할 세부적인 내용이 적다. 
단순함을 얻지만 제어력을 잃는다.

## 추상화 레벨 통일
컴퓨터와 마찬가지로 코드도 함수를 통해 추상화를 계층처럼 만들어서 사용할 수 있다.  
함수의 높은 레벨, 낮은 레벨를 구분해서 사용하는 원칙을 **추상화 레벨 통일(Single Level of Absraction, SLA) 원칙**이라고 부른다.

```kotlin
class CoffeeMachine {
    fun makeCoffee() {
        TODO("로직 구현")
    }
}
```
커피를 만드는 이 함수에 모든 로직을 구현하면 이 함수를 읽기 위해서는 세부적인 내용을 모두 이해해야한다.  
만약 수백줄의 코드가 된다면 이를 읽고 이해하는 건 거의 불가능에 가깝다.  
그래서 아래처럼 계층을 나누어 사용한다.

```kotlin
class CoffeeMachine {
    fun makeCoffee() {
        boilWater()
        brewCoffee()
        pourCoffee()
        pourMilk()
    }
}
```
이제 makeCoffee 함수는 읽고 이해하기 쉽다. 세부적인 내용은 낮은 레벨의 함수만 살펴보면 되어 가독성이 크게 향상되었다.

함수는 간단해야한다. ('함수는 작아야 하며 최소한의 책임만을 가져야한다.')  
함수가 복잡하다면 일부를 추출해서 추상화하는 것이 좋다.  
함수를 추출하면 재사용과 테스트가 쉬워진다.

```kotlin
// 함수를 재사용하여 에스프레소 커피를 만들 수 있다. 
fun makeEspressoCoffee() {
    boilWater()
    brewCoffee()
    pourCoffee()
}
```

## 프로그램 아키텍처의 추상레벨
추상화 계층 계념은 함수보다 높은 레벨에서도 적용할 수 있다.  
추상화를 구분하는 이유는 서브시스템의 세부사항을 숨김으로써 상호운영성과 플랫폼 독립성을 얻기 위함이다.  
이 개념은 모듈 시스템을 설계할 때도 중요하다.

- 낮은 레벨: 입출력을 나타내는 모듈
- 높은 레벨: 비지니스 로직

계층이 잘 분리된 프로젝트를 좋은 프로젝트라고 볼 수 있다. 어떤 계층에서 코드를봐도 일관적인 관점을 얻을 수 있다.
